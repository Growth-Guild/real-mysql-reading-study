# Chapter 10. 실행 계획

## 통계 정보
* MySQL 서버는 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
  * 테이블 컬럼 값들이 실제로 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어진다.
* MySQL 8.0 버전부터는 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

### MySQL 서버의 통계 정보
* MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선됐다.
* MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되어 서버가 재시작 되면 통계 정보가 휘발되었다.
* MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리할 수 있게 개션됐다.

## 히스토그램

### 히스토그램 정보 수집 및 삭제
* MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 ANALYZE TABLE ... UPDATE HISTOGRAM 명령을 실행해 수동으로 수집 및 관리된다.
* 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다.
  * 실제 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT해서 참조할 수 있다.
* MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.
  * Singleton(싱글톤 히스토그램): 컬럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고 불린다.
  * Equi-Height(높이 균형 히스토그램): 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고 불린다.
* 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리되는데, 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며 높이균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.
* 싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도의 비율의 2개 값을 가진다.
* 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.
* 히스토그램의 모든 레코드 건수 비율은 누적으로 표시된다. 
* 싱글톤 히스토그램은 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.
* 높이 균형 히스토그램은 컬럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다.
  * 그래프의 기울기가 일정하면 각 범위가 비슷한 레코드 건수를 가진다는 의미이다.
* 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.
  * 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다.

### 히스토그램의 용도
* 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
* 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
* 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.

### 히스토그램과 인덱스
* MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
* 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다.
  * 이를 "인덱스 다이브(Index Dive)"라고 표현한다.
* MySQL 8.0 서버에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
  * 실제 검색 조건의 대상 값에 대한 샘플링을 실행하기 때문에 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.
  * MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용한다.
* 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는(IN 절에 값이 많이 명시된 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 코스트 모델 (Cost Model)
* 전체 쿼리의 비용을 계산하는 데 피룡한 단위 작업들의 비용을 코스트 모델이라고 한다.
* MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.
  * 디스크로부터 데이터 페이지 읽기
  * 메모리(InnoDB 버퍼풀)로부터 데이터 페이지 읽기
  * 인덱스 키 비교
  * 레코드 평가
  * 메모리 임시 테이블 작업
  * 디스크 임시 테이블 작업
* MySQL 5.7 이전 버전까지는 위와 같은 작업들의 비용을 MySQL 서버 소스 코드에 상수화해서 사용했다.
  * 위 작업들의 비용은 하드웨어에 따라 달라질 수 있기 때문에 고정된 비용을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어서 방해 요소가 된다.
* MySQL 5.7 버전부터는 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선됐다.
* 코스트 모델은 MySQL 서버가 사용하는 하드웨어와 MySQL 서버 내부적인 처리 방식에 대한 깊이 있는 지식을 필요로 한다. 따라서 잘 모른다면 기본 값을 함부로 변경하지 않는게 낫다.
  * 그동안 기본 설정 값으로도 MySQL 서버는 잘 사용되어 왔다.
