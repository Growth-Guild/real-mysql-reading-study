# Chapter 10. 실행 계획

## 통계 정보
* MySQL 서버는 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
  * 테이블 컬럼 값들이 실제로 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어진다.
* MySQL 8.0 버전부터는 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.

### MySQL 서버의 통계 정보
* MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선됐다.
* MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되어 서버가 재시작 되면 통계 정보가 휘발되었다.
* MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리할 수 있게 개션됐다.

## 히스토그램

### 히스토그램 정보 수집 및 삭제
* MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 ANALYZE TABLE ... UPDATE HISTOGRAM 명령을 실행해 수동으로 수집 및 관리된다.
* 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다.
  * 실제 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT해서 참조할 수 있다.
* MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.
  * Singleton(싱글톤 히스토그램): 컬럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고 불린다.
  * Equi-Height(높이 균형 히스토그램): 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고 불린다.
* 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리되는데, 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며 높이균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.
* 싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도의 비율의 2개 값을 가진다.
* 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.
* 히스토그램의 모든 레코드 건수 비율은 누적으로 표시된다. 
* 싱글톤 히스토그램은 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.
* 높이 균형 히스토그램은 컬럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다.
  * 그래프의 기울기가 일정하면 각 범위가 비슷한 레코드 건수를 가진다는 의미이다.
* 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.
  * 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다.

### 히스토그램의 용도
* 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
* 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
* 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.

### 히스토그램과 인덱스
* MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
* 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다.
  * 이를 "인덱스 다이브(Index Dive)"라고 표현한다.
* MySQL 8.0 서버에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
  * 실제 검색 조건의 대상 값에 대한 샘플링을 실행하기 때문에 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.
  * MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용한다.
* 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는(IN 절에 값이 많이 명시된 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 코스트 모델 (Cost Model)
* 전체 쿼리의 비용을 계산하는 데 피룡한 단위 작업들의 비용을 코스트 모델이라고 한다.
* MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.
  * 디스크로부터 데이터 페이지 읽기
  * 메모리(InnoDB 버퍼풀)로부터 데이터 페이지 읽기
  * 인덱스 키 비교
  * 레코드 평가
  * 메모리 임시 테이블 작업
  * 디스크 임시 테이블 작업
* MySQL 5.7 이전 버전까지는 위와 같은 작업들의 비용을 MySQL 서버 소스 코드에 상수화해서 사용했다.
  * 위 작업들의 비용은 하드웨어에 따라 달라질 수 있기 때문에 고정된 비용을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어서 방해 요소가 된다.
* MySQL 5.7 버전부터는 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선됐다.
* 코스트 모델은 MySQL 서버가 사용하는 하드웨어와 MySQL 서버 내부적인 처리 방식에 대한 깊이 있는 지식을 필요로 한다. 따라서 잘 모른다면 기본 값을 함부로 변경하지 않는게 낫다.
  * 그동안 기본 설정 값으로도 MySQL 서버는 잘 사용되어 왔다.

## 실행 계획 확인
* 실행 계획은 EXPLAIN 명령으로 확인할 수 있다.

### 실행 계획 출력 포맷
* 이전 버전에서는 EXPLAIN EXTENDED 또는 EXPLAIN PARTITIONS 명령이 구분돼 있었지만, 8.0 버전부터는 내용이 통합되어 EXTENDED와 PARTITIONS 옵션이 문법에서 제거됐다.
* FORMAT 옵션을 통해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.
```sql
-- 테이블 포맷 표시
EXPLAIN
SELECT *
from employee e
    INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE first_name = 'ABC';

-- 트리 포맷 표시
EXPLAIN FORMAT=TREE
SELECT *
from employee e
       INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE first_name = 'ABC';

-- JSON 포맷 표시
EXPLAIN FORMAT=JSON
SELECT *
from employee e
       INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE first_name = 'ABC';
```

### 쿼리의 실행 시간 확인
* MySQL 8.0 버전부터는 쿼리의 실행 계확과 단계별 소요된 시간 정보를 확인할 수 있는 EXPLAIN ANALYZE 기능이 추가됐다.
* EXPLAIN ANALYZE 명령은 항상 TREE 포맷으로 보여주기 때문에 EXPLAIN 명령에 FORMAT 옵션을 사용할 수 없다.
* 실행 순서는 다음 기준으로 읽으면 된다.
  * 들여쓰기가 같은 레벨에서는 상단에 위치한 라인 먼저 실행
  * 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행
* EXPLAIN ANALYZE 명령의 결과는 아래와 같은 정보를 출력한다.
  * 단계별로 실제 소요된 시간(actual time)
  * 레코드 건수 (rows)
  * 반복 횟수 (loops)
* actual time은 첫 번째 레코드를 가져오는 데 결린 평균 시간을 의미한다.
* 숫자 값은 마지막 레코드를 가져오는 데 걸린 평균 시간을 의미한다.
* EXPLAIN ANALYZE 명령은 EXPLAIN 명령과 달리 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다.
* 쿼리의 실행 시간이 많이 걸리는 쿼리라면 EXPLAIN ANALYZE 명령을 사용하면 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있다.
* 쿼리의 실행 계획이 나쁜 경우라면 EXPLAIN 명령으로 먼저 실행 계확만 확인해서 어느 정도 튜닝한 후에 EXPLAIN ANALYZE 명령을 실행하는 것이 좋다.

## 실행 계획 분석
* 실행 순서는 위에서 아래로 순서대로 표시된다 (UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수 있다).
* 출력된 실행 계획에서 위쪽에 출력된 결과일수록(id 컬럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록(id 컬럼이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당한다.

### id 컬럼
* 하나의 SELECT 문장은 다시 1개 이상의 하위(SUB) SELECT 문장을 포함할 수 있다.
* id 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.
* 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.
* 쿼리 문장이 3개의 단위 SELECT 쿼리로 구성되는 경우에는 각 레코드가 다른 id를 가진다.
```sql
-- 같은 id가 부여되는 경우
SELECT e.emp_no,
       e.first_name,
       s.from_date,
       s.salary
FROM employees e, salaries s 
WHERE e.emp_no=s.emp_no LIMIT 10;

-- 각기 다른 id가 부여되는 경우
SELECT ( (SELECT COUNT(*)FROM employees) + (SELECT COUNT(*) FROM departments) ) AS total_count;
```
* id 컬럼은 테이블의 접근 순서를 의미하지 않는다.
* 테이블의 접근 순서는 EXPLAIN FORMAT=TREE 명령으로 확인해보면 순서를 더 정확히 알 수 있다.

### select_type 컬럼
* 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다.

#### SIMPLE
* UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 표시된다.
  * 쿼리에 조인이 포함된 경우에도 마찬가지다.
* 쿼리가 아무리 복잡하더라도 실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 하나만 존재한다.
  * 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE로 표시된다.

#### PRIMARY
* UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리에 표시된다.
* SIMPLE과 마찬가지로 PRIMARY인 단위 SELECT 쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.

#### UNION
* UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리에 표시된다.
* UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.

#### DEPENDENT UNION
* UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.
* DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.

#### UNION RESULT
* UNION 결과를 담아두는 테이블을 의미한다.
* MySQL 8.0 이전 버전에서는 UNION ALL이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시 테이블로 생성했다.
* MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다. (그럼 어디에 저장?)
* UNION(또는 UNION DISTINCT)은 8.0 버전에서도 여전히 임시 테이블에 결과를 버퍼링한다.
* UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니가 때문에 별도의 id 값은 부여되지 않는다.

#### SUBQUERY
* FROM 절 이외에서 사용되는 서브쿼리를 의미한다.
```sql
SELECT e.first_name,
       (SELECT COUNT(*)
        FROM dept_emp de, dept_manager dm
        WHERE dm.dept_no = de.dept_no) AS cnt
FROM employees e WHERE e.emp_no = 10001;
```
* FROM 절에서 사용된 서브쿼리는 select_type이 DERIVED로 표시되고, 위의 예제 쿼리와 같이 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.

##### 서브쿼리의 분류
* 서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다
  * 중첩된 쿼리(Nested Query): SELECT되는 컬럼에 사용된 서브쿼리를 네스티드 쿼리라고 한다.
  * 서브쿼리(Subquery): WHERE 절에 사용된 경우에는 일반적으로 그냥 서브쿼리라고 한다.
  * 파생 테이블(Derived Table): FROM 절에 사용된 서브쿼리를 MySQL에서는 파생 테이블이라고 하며, 일반적으로 RDBMS에서는 Inline View 또는 Sub Select라고 부른다.
* 서브쿼리는 반환하는 값의 특성에 따라 다음과 같이 구별하기도 한다.
  * 스칼라 서브쿼리(Scalar Subquery): 하나의 값만 반환하는 쿼리 (컬럼이 단 하나인 레코드 1건만 반환)
  * 로우 서브쿼리(Row Subquery): 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리

#### DEPENDENT SUBQUERY
* 서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 저으이된 컬럼을 사용하는 경우에 DEPENDENT SUBQUERY라고 표시된다.
```sql
SELECT e.first_name
    (SELECT COUNT(*)
    FROM dept_emp de, dept_manager dm
    WHERE dm.dept_no = de.dept_no AND de.emp_no = e.emp_no) AS cnt
FROM employees e 
WHERE e.first_name = 'Matt';
```
* 위와 같이 안쪽(Inner)의 서브쿼리 결과가 바깥쪽(Outer) SELECT 쿼리의 걸럼에 의존적이기 때문에 DEPENDENT 키워드가 붙는다.
* DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행돼야 하므로 DEPENDENT가 없는 서브쿼리보다는 처리 속도가 느릴 때가 많다.

#### DERIVED
* MySQL 5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 select_type이 DERIVED인 실행 계획을 만들었다.
* 5.6 버전부터는 옵티마이저 옵션에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.
* DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. (파생 테이블이라고도 한다)
* 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았지만 5.6 버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화 되었다.
* 파생 테이블에 대해 최적화가 부족한 버전의 MySQL 서버를 사용 중일 경우, 가능하다면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋다.
  * 8.0 버전부터는 FROM 절의 서브쿼리에 대한 최적화가 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리하지만, 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화 쿼리를 작성하는 것은 중요하다.

> 쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 컬럼의 값이 DERIVED인 것이 있는지 확인해야 한다.
> 서브쿼리를 조인으로 해결할 수 있는 경우라면 조인으로 사용하는 것이 좋다.

#### DEPENDENT DERIVED
* MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수가 없었는데, 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 되었다.
```sql
SELECT *
FROM employee e
LEFT JOIN LATERAL 
    ( 
    SELECT *
    FROM salaries s
    WHERE s.emp_no = e.emp_no
    ORDER BY s.from_date DESSC LIMIT 2 
  ) AS s2 ON s2.emp_no = e.emp_no;
```
* 위 쿼리의 예시는 employees 테이블의 레코드 1건당 salaries 테이블의 레코드를 최근 순서대로 최대 2건까지만 가져와서 조인을 실행한다.
* 래터럴 조인의 경우에는 LATERAL 키워드를 사용해야 하며, LATERAL 키워드가 없는 서브쿼리에서 외부 컬럼을 참조하면 오류가 발생한다.
* 실행 계획에서는 select_type 컬럼에 DEPENDENT DERIVED 표시되는데, 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.

#### UNCACHEABLE SUBQUERY
* 하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.
* 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.
  * 여기서 말하는 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 무관한 기능이다.
* SUBQUERY는 바깥쪽(Outer)의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
* DEPENDENT SUBQUERY는 의존하는 바깥쪽(Outer) 쿼리의 컬럼의 값 단위로 캐시하여 사용한다.
* select_type이 SUBQUERY인 경우와 UNCACHEABLE SUBQUERY는 이 캐시를 사용할 수 있느냐 없느냐의 차이다.
* 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우에 UNCACHEABLE SUBQUERY로 표시된다.
* 캐시를 사용하지 못하게 하는 요소는 아래와 같다.
  * 사용자 변수가 서브쿼리에 사용된 경우
  * NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
  * UUID()나 RAND()와 같이 결과값이 호출될 때마다 달라지는 함수가 서브쿼리에 사용된 경우

#### UNCACHEABLE UNION
* UNCACHEABLE UNION은 UNCACHEABLE과 UNION 키워드의 속성이 혼합된 것으로 맥락은 UNCACHEABLE SUBQUERY와 같다.

#### MATERIALIZED
* MySQL 5.6 버전부터 도입된 select_type으로, 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
* 5.6 버전까지는 IN(subquery)의 형태가 FROM 테이블을 읽어서 해당 레코드마다 subquery 테이블을 읽는 형태로 실행됐다.
* 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화한 후, 임시 테이블과 선행 테이블을 조인하는 형태로 최적화되어 처리된다.

### table 컬럼
* MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.
* table 컬럼에 <derived N> 또는 <union M,N>과 같이 "<>"로 둘러싸인 이름이 명시되는 경우, 이 테이블은 임시 테이블임을 의미한다.
* "<>"안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 지칭한다.


### partitions 컬럼
* MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAIN PARTITION 명령을 이용해 확인 가능했지만 MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 확인할 수 있게 변경됐다.
* 파티션 키로 사용되는 컬럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.
* 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝(Partition pruning)이라고 한다.
* MySQL을 퐇마한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가진다.
  * 따라서 partition 컬럼에 특정 파티션이 나타나는 경우에 해당 파티션 테이블을 선택하여 읽는다는 의미이다.

### type 컬럼
* 실행 계획에서 type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식을 읽었는지를 나타낸다. (인덱스를 읽었는지, 아니면 풀 테이블 스캔을 했는지 등..)
* type 컬럼은 각 테이블의 접근 방법으로 해석하면 된다.
* type 컬럼은 ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.
* 하나의 단위 SELECT 쿼리는 여러 접근 방법 중에서 하나만 사용할 수 있고, index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다.
  * 따라서 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외의 type에서는 인덱스 항목에도 단 하나의 인덱스 이름만 표시된다.

#### system
* 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않은 테이블을 참조하는 형태의 접근 방법이다.
* InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.

#### const
* 테이블의 레코드 건수와 상관없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다.
* 다른 DBMS에서는 이를 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고도 표현한다.
* 다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스 일부 컬럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다.
  * 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다.
* 프라이머리 키의 일부만 조건으로 사용할 때는 type 컬럼에 const가 아닌 ref로 표시된다.
* type 컬럼이 const인 실행 계획은 MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다.
```sql
SELECT COUNT(*)
FROM employees e1
WHERE first_name = (SELECT first_name FROM employees e2 WHERE emp_no = 10001);

-- 위 쿼리는 const 타입으로, 옵티마이저에 의해 최적화되는 시점에 아래와 같이 변환된다.

SELECT COUNT(*)
FROM employees e1
WHERE first_name = 'Jasminko'; -- Jasminko는 사번에 10001인 사원의 first_name 값이다.
```

#### eq_ref
* 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
* 조인에서 처음 읽는 테이블의 컬럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.
* 두 번째 이후에 읽는 테이블의 type 컬럼에 eq_ref가 표시된다.
* 다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용돼야 eq_ref 접근 방법이 사용될 수 있다.
* 조인에서 두 번째 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

#### ref
* ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키등의 제약 조건도 없다.
* 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다.
* ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다 빠르지 않다.

#### fulltext
* MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.
* system, const, eq_ref, ref 다음으로 fulltext의 순서가 일반적인 처리 성능의 순서이긴 하지만 실제로 데이터의 분포나 레코드의 건수에 따라 빠른 순서는 달라질 수 있다.
  * 이는 비용 기반의 옵티마이저에서 통계 정보를 이용해 비용을 계산하는 이유이기도 하다.
* 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.
* MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다.
  * 일반 인덱스의 접근 방법이 const, eq_ref, ref가 아니면 일반저그올 MySQL은 전문 인덱스를 사용하는 조건을 선택해서 처리한다.
* 전문 검색은 "MATCH (...) AGAINST (...)" 구문을 사용해서 실행한다. 테이블에 전문 인덱스가 없다면 쿼리는 오류가 발생하고 중단된다.
* 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 많으므로 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋다.

#### ref_or_null
* ref 접근 방법과 같고, NULL 비교가 추가된 형태다.

#### unique_subquery
* WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
* 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

#### index_subquery
* IN 연산자의 특성상 IN(subquery) 또는 IN(상수 나열) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.
* IN(subquery)에서 서브쿼리의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.
* unique_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않다.
* index_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있다.

#### range
* 인덱스 레인지 스캔 형태의 접근 방법이다.
* range는 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.
* 주로 "<, >, is NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용해 인덱스를 검색할 때 사용한다.
* 일반적인 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법이다.
* 접근 방법의 순서상 MySQL 서버가 가지고 있는 접근 방법 중에서 우선순위가 낮지만, 읽어야 하는 레코드 건수에 따라 차이가 있을 수 있다.
* range 접근 방법도 상당히 빠르고, 모든 쿼리가 이 접근 방법만 사용해도 ㅚ적화의 성능이 보장된다.

#### index_merge
* 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.
* 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
* 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
* index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

#### index
* index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스를 풀 스캔을 의미한다.
  * range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니다.
* 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있다.
* index 접근 방법은 다음 조건 가운데 (첫 번째 + 두 번째) 조건을 충족하거나(첫 번째 + 세 번째) 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.
  * range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  * 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우(즉, 데이터 파일을 읽지 않아도 되는 경우)
  * 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우(즉, 별도의 정렬 작업을 피할 수 있는 경우)

#### ALL
* 풀 테이블 스캔을 의미하는 접근 방법이다.
* 위에서 설명한 접근 방법들로는 처리할 수 없을 때 가장 마지막에 선택하는 가장 비효율적인 방법이다.
* InnoDB는 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 IO를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능을 제공하는데, 이를 리드 어페드(Read Ahead)라고 한다.
* 리드 어헤드 작업은 한 번에 여러 페이지를 읽어서 처리할 수 있도록 해준다.
* 일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 요구하는 웹 서비스 등과 같은 OLTP 환경에는 적합하지 않다.
* 테이블이 매우 작지 않다면 실제로 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용하는 것이 좋다.

##### 리드 어헤드
* MySQL 서버에서는 인접한 페이지가 연속해서 몇 번 읽히면 백그라운드로 작동하는 읽기 스레드가 최대 64개 페이지씩 한꺼번에 디스크로부터 읽어 들이기 때문에 한 번에 페이지 하나씩 읽어 들이는 작업보다 상당히 빠르게 레코드를 읽을 수 있다.

### possible_keys 컬럼
* 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다.
* possible_keys 컬럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록이다.
* possible_keys 컬럼에 인덱스 이름이 나열됐다고 해서 해당 인덱스가 사용됐다고 판단해서는 안된다.

### key 컬럼
* key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
* 쿼리를 튜닝할 때는 key 컬럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.
* key 컬럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이며, 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다.
* index_merge가 사용되는 경우에 key 컬럼에는 ','로 구분된 여러 인덱스가 표시된다.
* 실행 계획의 type이 ALL일 때와 같이 인덱스를 전혀 사용하지 못하면 key 컬럼은 NULL로 표시된다.

### key_len 컬럼
* 실행 계획의 key_len 컬럼 값은 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 알려준다.
  * 좀더 구체적으로는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지를 알려주는 값이다.
* 다중 컬럼 인덱스뿐 아니라 단일 컬럼으로 만들어진 인덱스에서도 같은 지표를 제공한다.
* key_len 필드의 값이 데이터 타입의 길이보다 조금 길게 표시되는 경우도 있는데, 이는 NULLABLE 컬럼으로 정의되어 NULL이 저장될 수 있기 때문이다.

### ref 컬럼
* 접근 방법이 ref면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다.
* 상수값을 지정다면 ref 컬럼은 const로 표시되고, 다른 테이블의 컬럼값이면 그  테이블명과 컬럼명이 표시된다.
* 실행 계획에서 ref 컬럼의 값이 func라고 표시될 때가 있는데, 이는 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.
* 사용자가 명시적을 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 컬럼에는 func가 출력된다.
  * 문자집합이 일치하지 않는 두 문자열 컬럼을 조인한다거나 숫자 타입의 컬럼과 문자열 타입의 컬럼으로 조인할 때가 대표적인 예다.
  * 가능하다면 MySQL 서버가 이련 변환을 하지 않아도 되게 조인 컬럼의 타입은 일치시키는 편이 좋다.

### rows 컬럼
* MySQL 실행 계획의 rows 컬럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
* rows 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.
* rows 컬럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코들르 읽고 체크해야 하는지를 의미한다.
* 가끔 인덱스되지 않은 컬럼이나 컬럼의 값이 균등하게 분포되지 않은 경우에도 제대로 된 예측을 못할 수도 있다. 이런 경우를 위해 MySQL 8.0부터는 히스토그램이 도입됐다.

### filtered 컬럼
* 실행 계획에서 rows 컬럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다.
* filtered 컬럼의 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.
* 옵티마이저는 레코드 건수뿐만 아니라 다른 요소들도 충분히 감안해서 실행 계획을 수립하지만 조인의 횟수를 줄이고 그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택할 가능성이 높다.
* filtered 컬럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라진다.
* MySQL 8.0에서는 filtered 컬럼의 값을 더 정확히 예측할 수 있도록 히스토그램 기능이 도입됐다.

### Extra 컬럼
* Extra 컬럼에는 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많다.

#### const row not found
* 쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 Extra 컬럼에 const row not found가 표시된다.

#### Deleting all rows
* MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우 Extra 컬럼에 "Deleting all rows" 문구가 표시된다.
* WHERE 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시되며, 이 문구는 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한 번 호출함으로써 처리됐다는 것을 의미한다.
* MySQL 8.0 버전에서는 InnoDB 스토리지 엔진과 MyISAM 엔진 모두 더 이상 "Deleting all rows" 최적화는 표시되지 않는다.
  * 테이블의 모든 레코드를 삭제하고자 한다면 WHERE 조건절이 없는 DELETE보다 TRUNCATE TABLE 명령을 사용할 것이 좋다.

#### Distinct
* 쿼리에서 조회하려는 값을 중복 없이 유니크하게 가져오기 위해 Distinct를 사용했을 때 나타나는 키워드다.
* 조인쿼리에서 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목들은 모두 무시하고 꼭 필요한 것만 조인한다.

#### FirstMatch
* 세미 조인 여러 최적화 중에서 FirstMatch 전략이 사용되면 "FirstMatch(table_name)" 메시지를 출력한다.
* FirstMatch 메시지에 함께 표시되는 테이블명은 기준 테이블을 의미한다.

#### Full scan on NULL key
* 이 처리는 "col1 IN (SELECT col2 FROM ...)"과 같은 조건을 가진 쿼리에서 자주 발생할 수 있는데, col1의 값이 NULL이 된다면 결과적으로 조건은 "NULL IN (SELECT col2 FROM ...)"과 같이 바뀐다.
* SQL 표준에서는 NULL을 "알 수 없는 값"으로 정의하고 있으며, NULL에 대한 연산 규칙까지 정의하고 있다.
  * 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
  * 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE
* 위 비교 과정에서 col1이 NULL이면 서브쿼리에 사용된 테이블에 대해서 풀 테이블 스캔(Full scan)을 해야만 결과를 알아낼 수 있다.
* Extra 컬럼의 "Full scan on NULL key"는 MySQL 서버가 쿼리를 실행하는 중 col1이 NULL을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드다.
* col1 컬럼이 NOT NULL로 정의되어 있다면 이러한 차선책은 사용하지 않고 Extra 컬럼에도 표시되지 않는다.
* 컬럼이 NOT NULL로 정의되지는 않았지만 이러한 NULL 비교 규칙을 무시해도 된다면 col1이 절대 NULL은 될 수 없다는 것을 MySQL 옵티마이저에게 알려주면 된다.
  * 쿼리의 조건에 "col1 IS NOT NULL"이라는 조건을 지정하면 된다.
  * 그러면 col1이 NULL일 때, "col1 IS NOT NULL" 조건이 FALSE가 되어 후속 조건인 "col1 IN (SELECT col2 FROM tb_test2)" 조건은 실행하지 않는다.
* "Full scan on NULL key" 코멘트가 실행 계획의 Extra 컬럼에 표시됐다고 하더라도 IN이나 NOT IN 연산자의 왼쪽에 있는 값이 실제로 NULL이 없다면 tb_test2 테이블에 대한 풀 테이블 스캔은 발생하지 않는다.

#### Impossible HAVING
* 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 실행 계획의 Extra 컬럼에는 "Impossible Having" 키워드가 표시된다.

#### Impossible WHERE
* "Impossible HAVING"과 비슷하며, WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우에 표시된다.

#### LooseScan
* 세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용되면 표시된다.
