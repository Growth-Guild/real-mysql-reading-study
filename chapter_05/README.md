# 05. 트랜잭션과 잠금

## 트랜잭션

### MySQL에서의 트랜잭션
* 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋이 모두 적용(COMMIT을 실행했을 때) 아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 ROLLBACK시키는 오류가 발생했을 때) 함을 보장하는 것이다.

### InnoDB와 MyISAM의 트랜잭션

```mysql
CREATE TABLE tab_myisam (
    foo INT NOT NULL,
    PRIMARY KEY (foo)
) ENGINE=MyISAM;

CREATE TABLE tab_innodb (
    foo INT NOT NULL,
    PRIMARY KEY (foo)
) ENGINE=INNODB;

INSERT INTO tab_myisam (foo) VALUES (3);
INSERT INTO tab_innodb (foo) VALUES (3);

-- ----------------------------------------
INSERT INTO tab_myisam (foo) VALUES (1), (2), (3);
INSERT INTO tab_innodb (foo) VALUES (1), (2), (3);
```

* InnoDB는 3 값이 INSERT 될 때 프라이머리 키의 중복 오류로 인해 트랜잭션이 롤백되어 1, 2 값 또한 INSERT 되지 않고 모두 실패한다.
* MyISAM은 3 값이 INSERT 될 때 프라이머리 키의 중복 오류로 인해 실패하더라도 앞의 1, 2의 INSERT는 이미 저장되어 부분 업데이트가 된다.
* MyISAM은 이러한 부분 업데이트로 인해 테이블 데이터의 정합성을 맞추는데 어려운 문제를 만들어낸다.

## 주의사항
* 트랜잭션은 꼭 필요한 최소한의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화하는 것이 좋다는 의미이다.
* 일반적으로 데이터베이스 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어든다.
* 메일 전송, 파일 업로드, 네트워크 호출을 통한 통신 등과 같은 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.

## MySQL 엔진의 잠금
* MySQL에서 사용되는 잠금은 스토리지 엔진 레발과 MySQL 엔진 레벨로 나눌 수 있다.
* MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락 (Global Lock)
* 글로벌 락은 'FLUSH TABLES WITH READ LOCK' 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
* 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL이나 DML을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
* 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
* 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치므로 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋다.
* InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.

### 테이블 락 (Table Lock)
* 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
  * 명시적으로는 'LOCK TABLES table_name \[ READ | WRITE \]' 명령으로 특정 테이블의 락을 획득할 수 있다.
  * 명시적으로 획득한 잠금은 'UNLOCK TABLES' 명령으로 잠금을 해체할 수 있다.
* 테이블 락은 MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다.
* 명시적인 락도 특별한 상황이 아니라면 애플리케이션에서 사용할 필요가 거의 없고, 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.
* 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
  * 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 자동 해체된다.
* InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.
  * 더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

### 네임드 락 (Named Lock)
* 네임드 락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
* 네임드 락은 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라, 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.

### 메타데이터 락 (Metadata Lock)
* 데이터베이스 객체(테이블이나 뷰 등..)의 이름이나 구조를 변경하는 경우에 획득하는 락이다.
* 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 'RENAME TABLE foo TO bar' 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

## InnoDb 스토리지 엔진 잠금
* InnoDb 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 사용한다.
* 레코드 기반의 잠금 방식 덕분에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
* 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용하는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 까다롭다.
* 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.
* InnoDB 스토리지 엔진에서는 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이 있다.

### 레코드 락 (Record lock)
* 레코드 자체만을 잠그는 것을 레코드 락이라고 한다.
* InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
* 인덱스가 하나도 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
* 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

### 갭 락 (Gap Lock)
* 갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠근다.
* 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다.
* 갭 락은 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.

### 넥스트 키 락 (Next key lock)
* 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.
* InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
* 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하므로, 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키락이나 갭 락을 줄이는 것이 좋다.
  * ROW 형태로 바꾸면 왜 줄어드는거지??

### 자동 증가 락 (Auto increment lock)
* MySQL에서는 자동 증가하는 숫자 값을 채번하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공하는데, 해당 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.
* InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.
* AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.
* InnoDB의 다른 잠금(레코드 락이나 넥스트 키 락)과는 달리 AUTO_INCREMENT 락은 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락을 걸었다가 즉시 해제된다.
* AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 다른 쿼리는 해당 락을 기다려야 한다.
  * AUTO_INCREMENT 컬럼에 명시적으로 값을 설정하더라도 AUTO_INCREMENT 락을 건다.
* AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 없으며, 아주 짧은 시간동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다.
* 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유는 AUTO_INCREMENT 잠금을 최소화하기 위해서다.
  * INSERT 쿼리가 실패했더라도 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남는다.
