# Chapter 8. 인덱스

## 디스크 읽기 방식
* 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
* 컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다.
  * 데이터베이스 서버에서 항상 디스크 장치가 병목이 되는 원인이다.
* SSD는 기존 HDD에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리를 장착하고 있다.
  * 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 HDD보다 빠르게 데이터를 읽을 수 있다. (컴퓨터의 메모리보다는 느리다.)
* SSD의 장점은 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다는 것이다.
* 데이터베이스 서버에서 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD는 DBMS용 스토리지로 적합하다.

### 랜덤 I/O와 순차 I/O
* 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
  * 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O 작업이 부하가 훨씬 크다.
* 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.
* 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.
  * 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
  * 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.
> 디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것 같지만, 실제로는 SSD에서도 랜덤 I/O가 순차 I/O보다 전체 스루풋(Throughput)이 떨어진다.
```text
인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀테이블 스캔은 순차 I/O를 사용한다.
그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.
순차 I/O가 랜덤 I/O보다 훨씬 빠른 속도로 레코드를 읽을 수 있기 때문이다.
이런 형태는 주로 OLTP 성격의 웹 서비스보다는 데이터 웨어하우스나 통계작업에서 주로 사용된다.
```

## 인덱스
* 컬럼의 값을 주어진 순서로 미리 정렬해서 보관하는 것이다.
* DBMS의 인덱스는 SortedList와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.
* DBMS의 인덱스는 SortedList처럼 저장되는 컬럼의 값을 이용해 항상 정렬된 상태를 유지한다.
* 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 저장한다.
* SortedList는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 읽기 연산에서는 이미 정렬이 되어 있기 떄문에 빠른 성능을 보인다.
* 결과적으로 DBMS에서 인덱스는 데이터의 저장(CUD) 성능을 희생하고, 데이터의 읽기 속도를 높이는 기능이다.
* 데이터 저장 방식의 대표적인 구조는 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.
* 데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
  * 유니크의 여부는 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 옵티마이저에겐 중요한 정보이다.
  * 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.

## B-Tree 인덱스
* 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
* 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도로 적합하다.

### B-Tree의 구조 및 특성
* 트리 구조의 최상위에 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
* 트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.
* 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
> 대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
* 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
  * 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.
  * MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면, InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.
* InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.
  * 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.
  * 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다.


### B-Tree 인덱스 키 추가
* 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
* B-Tree에 저장될 때는 저장할 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.
* 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
* 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
  * 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 든다.
* MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행됨녀 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
* InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜서 나중에 처리할 수 있다.
  * 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가되거나 삭제한다.

### B-Tree 인덱스 키 삭제
* 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료되므로 간단하다.
* 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
* 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 발생한다.
* MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 버퍼링되어 지연 처리될 수도 있다.
  * MyISAM이나 MEMORY 스토리지 엔진의 테이블에는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.

### 인덱스 키 변경
* 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경할 수 없다.
* B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
* InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 체인지 버퍼를 활용해 지연 처리될 수 있다.

### 인덱스 키 검색
* 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이를 '트리 탐색'이라 한다.
* 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다.
* B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
* 부등호("<, >") 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
* InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.
  * UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 활용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.

## B-Tree 인덱스 사용에 영향을 미치는 요소

### 인덱스 키 값의 크기
* InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위는 페이지(Page) 또는 블록(Block)이라고 한다.
  * 디스크의 모든 I/O 작업의 최소 작업 단위다.
  * 버퍼 풀에서 데이터를 버퍼링하는 기본 단위다.
* 인덱스는 페이지 단위로 관리된다.
* B-Tree의 자식 노드 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
* 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 증가하고, 그에 따라 성능이 느려진다.

### B-Tree 깊이
* B-Tree 인덱스의 깊이는 중요하지만 제어할 방법은 없다.
* B-Tree의 깊이는 값을 검색할 때 디스크에서 랜덤 액세스가 얼마나 발생하는지와 직결된다.
  * 인덱스 키 값의 크기가 커지면 하나의 인덱스 페이지에 담을 수 있는 인덱스 키 값의 개수가 적어지고, 같은 레코드 건수라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요해진다.
* 인덱스 키 값의 크기는 작게 만드는 것이 좋다.

### 선택도(기수성)
* 인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용된다.
* 기수성은 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
  * 기수성이 높다는 것은 그만큼 유니크한 값의 수가 많다는 의미하고, 검색 대상이 줄어들기 때문에 성능이 빨라진다.

### 읽어야 하는 레코드의 건수
* 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블을 읽는 것보다 높은 비용이 든다.
* 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드를 1건 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도의 비용이 더 드는 작업으로 예측한다.
  * 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 더 효율적이다.

## B-Tree 인덱스가 데이터를 읽는 방법

### 인덱스 레인지 스캔
* 인덱스 레인지 스캔은 검색해야 하는 인덱스의 범위가 결정됐을 때 사용하는 방법이다.
* 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾는다.
* 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다.
* 스캔의 결과로 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 가져오는데, 별도로 정렬을 수행한 것이 아니라 인덱스 자체가 정렬되어 있기 때문이다.
* 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어올 때 레코드 단위로 랜덤 I/O가 한 번씩 일어난다.
  * 인덱스를 통해 데이터 레코드를 읽는 작업이 비용이 많이 드는 이유이다.

#### 인덱스 레인지 스캔 절차
1. 인덱스 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다. (Index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽는다. 이 과정을 인덱스 스캔이라고 한다. (Index scan)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.

* 쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다.
* 커버링 인덱스는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다.

### 인덱스 풀 스캔
* 인덱스의 처음부터 끝까지 모두 읽는 방식이다.
* 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우에 사용된다.
  * (A, B, C) 컬럼 순서로 인덱스가 만들어져 있지만 쿼리 조건절은 B컬럼이나 C컬럼으로 검색하는 경우다.
* 일반적으로는 인덱스의 크기가 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 더 효율적이다.
  * 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 이 방식이 사용된다.
  * 인덱스 뿐만 아니라 데이터 레코드까지 읽어야 하면 인덱스만 읽는 방식으로 처리되지 않는다.

### 루스 인덱스 스캔
* '인덱스 레인지 스캔'과 '인덱스 풀 스캔'은 루스 인덱스 스캔과 상반된 의미에서 '타이트(Tight) 인덱스 스캔'으로 분류한다.
* 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
* 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
* 일반적으로 Group BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 사용하는 경우에 사용한다.
