# Chapter 8. 인덱스

## 디스크 읽기 방식
* 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
* 컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다.
  * 데이터베이스 서버에서 항상 디스크 장치가 병목이 되는 원인이다.
* SSD는 기존 HDD에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리를 장착하고 있다.
  * 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 HDD보다 빠르게 데이터를 읽을 수 있다. (컴퓨터의 메모리보다는 느리다.)
* SSD의 장점은 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다는 것이다.
* 데이터베이스 서버에서 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD는 DBMS용 스토리지로 적합하다.

### 랜덤 I/O와 순차 I/O
* 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
  * 여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O 작업이 부하가 훨씬 크다.
* 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.
* 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.
  * 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
  * 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.
> 디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것 같지만, 실제로는 SSD에서도 랜덤 I/O가 순차 I/O보다 전체 스루풋(Throughput)이 떨어진다.
```text
인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀테이블 스캔은 순차 I/O를 사용한다.
그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.
순차 I/O가 랜덤 I/O보다 훨씬 빠른 속도로 레코드를 읽을 수 있기 때문이다.
이런 형태는 주로 OLTP 성격의 웹 서비스보다는 데이터 웨어하우스나 통계작업에서 주로 사용된다.
```

## 인덱스
* 컬럼의 값을 주어진 순서로 미리 정렬해서 보관하는 것이다.
* DBMS의 인덱스는 SortedList와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.
* DBMS의 인덱스는 SortedList처럼 저장되는 컬럼의 값을 이용해 항상 정렬된 상태를 유지한다.
* 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 저장한다.
* SortedList는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 읽기 연산에서는 이미 정렬이 되어 있기 떄문에 빠른 성능을 보인다.
* 결과적으로 DBMS에서 인덱스는 데이터의 저장(CUD) 성능을 희생하고, 데이터의 읽기 속도를 높이는 기능이다.
* 데이터 저장 방식의 대표적인 구조는 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.
* 데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
  * 유니크의 여부는 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 옵티마이저에겐 중요한 정보이다.
  * 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.

## B-Tree 인덱스
* 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
* 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도로 적합하다.

### B-Tree의 구조 및 특성
* 트리 구조의 최상위에 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
* 트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.
* 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
> 대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
* 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
  * 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.
  * MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면, InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.
* InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.
  * 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.
  * 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색해야 한다.
