# Chapter 9. 옵티마이저와 힌트

## 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

* 첫 번째 단계를 "SQL 파싱"이라고 하며, MySQL 서버의 "SQL 파서"라는 모듈로 처리한다.
  * SQL 문장이 문법적으로 잘못 됐다면 이 단계에서 걸러진다.
  * 이 단계에서 "SQL 파스 트리"가 만들어진다.
  * MySQL 서버는 SQL 문장이 아닌, SQL 파스 트리를 이용하여 쿼리를 실행한다.
* 두 번째 단계에서는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.
  * 불필요한 조건 제거 및 복잡한 연산 단순화
  * 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  * 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
  * 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
* 두 번째 단계는 "최적화 및 실행 계획 수립" 단계이며, MySQL 서버의 옵티마이저에서 처리한다.
  * 이 단계가 완료되면 실행 계획이 만들어진다.
* 세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.
* 첫 번째 단계와 두 번째 단계는 거의 MySQL 엔진에서 처리하며, 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

### 옵티마이저의 종류
* 비용 기반 최적화(Cost-based optimizer, CBO)
  * 현재 대부분의 RDMS가 선택하고 있는 옵티마이저 최적화 방법이다.
  * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
  * 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.
* 규칙 기반 최적화(Rule-based optimizer, RBO)
  * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식이다.
  * 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 낸다.
  * 오래전부터 많은 RDBMS에서 거의 사용하지 않는다.

## 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔
* 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리한다.
  * 테이블의 레코드 건수가 너무 적어서 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 더 빠른 경우에 풀 테이블 스캔을 사용한다.
  * WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우에 풀 테이블 스캔을 사용한다.
  * 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)에 풀 테이블 스캔을 사용한다.
* 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 대량의 디스크 읽기 작업을 필요로 한다.
* InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작된다.
* 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측하여 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 캐싱해 두는 것을 의미한다.
  * 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
* 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용된다.

## 병렬 처리
* MySQL 8.0 버전부터는 용도가 한정되어 있긴 하지만 쿼리의 병렬 처리가 가능해졌다.
* 여기서 말하는 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것을 의미한다.
* 책의 쓰여질 당시에는 쿼리를 여러 개의 스레드에서 병렬 처리하도록 하는 힌트나 옵션은 없다고 한다.
* 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있으니 주의해야 한다.

## ORDER BY 처리 (Using filesort)
* 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
* 인덱스를 사용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 컬럼에 "Using filesort" 메시지가 표시되는지 여부로 판단할 수 있다.

### 인덱스를 이용하는 방법
* 장점
  * INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 빠르다.
* 단점
  * INSERT, UPDATE, DELTE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
  * 인덱스로 인해 디스크 공간이 더 필요하다.
  * 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.

### Filesort를 이용하는 방법
* 장점
  * 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
  * 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
* 단점
  * 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

### 모든 정렬을 인덱스를 이용하도록 튜닝하기 어려운 이유 
* 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우

### 소트 버퍼
* 정렬을 수행하기 위해서 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼(Sort buffer)라고 한다.
* 소프 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 시스템 변수로 설정 가능하다.
* 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
* MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.
* MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나뉘어 있는데, 소트 버퍼는 세션 메모리 영역에 해당된다.

## 정렬 알고리즘
* 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 "싱글 패스"와 "투 패스" 2가지 정렬 모드로 나눌 수 있다.

### 싱글 패스 정렬 방식
* 소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.
```sql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```
* 싱글 패스 정렬 방식에서 위 쿼리는 emp_no, first_name, last_name을 소트 버퍼에 모두 담고 정렬을 수행한다.

### 투 패스 정렬 방식
* 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식이다.
* 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.
* MySQL 8.0 버전에서도 여전히 특정 조건에서는 투 패스 정렬 방식을 사용한다.

### 싱글 패스 정렬 방식과 투 패스 정렬 방식
* 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다.
* 투 패스 방식은 테이블을 두 번 읽어야 하는 불합리가 있다.
* 최신 버전의 MySQL에서는 싱글 패스 정렬 방식을 주로 사용하지만 다음의 경우에는 싱글 패스 정렬 방식을 사용하지 못하고 투 패스 정렬 방식을 사용한다.
  * 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
  * BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될 때
* 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우에 따른 성능을 보인다.
* 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우에 효율적이다.
* SELECT 쿼리에서 필요한 컬럼만 조회하지 않고 모든 컬럼(*)을 조회하도록 개발하는 방식은 성능이 중요한 기능이라면 지양해야 한다.
  * 정렬 버퍼를 비효율적으로 사용하기 떄문이다.
  * 임시 테이블이 필요한 쿼리에서도 영향을 미친다.

### 정렬 처리 방법
* 쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 되며, 아래쪽에 있는 정렬 방법으로 갈수록 느리다.

| 정렬 처리 방법                    | 실행 계획의 Extra 컬럼 내용                         |
|-----------------------------|--------------------------------------------|
| 인덱스를 이용한 정렬                 | 별도 표기 없음                                   |
| 조인에서 드라이빙 테이블만 정렬           | "Using filesort" 메시지가 표시됨                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort" 메시지가 표시됨 |

* 일반적으로 조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 떄문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.
* 두 번째 방법보다는 첫 번째 방법이 더 효율적이다.

### 인덱스를 이용한 정렬
* 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우에는 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
* 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 이 방식을 사용할 수 있다.
* 네스티드 루프 조인? (Nested Loop Join)
  * 드라이빙 테이블의 처리 범위를 하나씩 액세스 하면서 그 추출된 값으로 드리븐 테이블을 조인하는 방식이다. (중첩된 반복문과 유사한 방식)
  * 결과 행의 수가 적은 테이블을 조인 순서상 선행 테이블로 선택하는 것이 성능에 좋다.
  * 랜덤 액세스 방식으로 접근하기 때문에 처리 범위가 좁은 조건을 선택하는 것이 유리하다.
* 인덱스를 이용한 정렬을 수행하는 경우에는 실제 인덱스의 값이 이미 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.
  * 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다.
  * ORDER BY가 있든 없든 같은 인덱스를 레인지 스캔해서 나온 결과는 같은 순서로 정렬되어 있다.
  * ORDER BY 절을 넣지 않아도 자동으로 정렬이 된다고 해서 ORDER BY 절을 제거하는 행동은 좋지 않다.
  * 어떤 이유로 쿼리의 실행 계획이 조금 변경되다면 ORDER BY가 명시되지 않은 쿼리는 기대했던 순서로 가져오지 못해서 어플리케이션 상에서 버그로 연결될 수 있기 떄문이다.
  * 인덱스로 정렬이 될 떄는 ORDER BY가 쿼리에 명시된다고 해서 작업량이 더 늘지 않으므로 명시적으로 처리하자.
* 네스티드-루프 방식으로 실행되기 때문에 조인으로 인한 드라이빙 테이블의 인덱스 읽기 순서는 바뀌지 않는다.
* 조인이 사용된 쿼리의 실행 계획에 조인 버퍼(Join buffer)가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

### 조인의 드라이빙 테이블만 정렬
* 이 방법으로 정렬이 처리되려면 조인에서 드라이빙 테이블의 컬럼만으로 ORDER BY 절을 작성해야 한다.

### 임시 테이블을 이용한 정렬
* 조인의 드라이빙 테이블을 이용한 정렬 외에 다른 패턴의 쿼리는 항상 조인의 결과를 임시 테이블에 저장해야 하고, 그 결과를 다시 정렬하는 과정을 거친다.
* 이 방법은 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.
* ORDER BY 절의 정렬 기준 컬럼이 드리븐 테이블에 있는 컬럼인 경우에는 정렬이 수행되기 전에 드리븐 테이블을 읽어야 하므로 조인의 결과를 임시 테이블에 저장해야 한다.
* 실행 계획에서 살펴봤을 때 Extra 컬럼에 "Using temporary; Using filesort" 코멘트가 표시된다.
  * 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.
