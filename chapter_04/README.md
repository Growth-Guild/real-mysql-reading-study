# 04. 아키텍처

## MySQL 엔진아키텍처
![img.png](assets/mysql_server_architecture.png)
* MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

### MySQL 엔진
* MySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.

### 스토리지 엔진
* MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
* 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다.
* MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. (INNODB 등..)
* 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 Read/Write는 정의된 스토리지 엔진이 처리한다.

### 핸들러 API
* MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 떄는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다.
* InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고받는다.

## MySQL 스레딩 구조
![img.png](assets/mysql_threading_model.png)
* MySQL 서버는 스레드 기반으로 작동한다.
* 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분된다.
* 위의 스레드 모델은 MySQL 커뮤니티 에디션에서 사용되는 전통적인 모델이며, MySQL 엔터프라이즈 에디션과 Percona MySQL 서버에서는 전통적인 스레드 모델뿐 아니라 스레드 풀 모델을 사용할 수도 있다.
  * 전통적인 스레드 모델은 커넥션별로 포그라운드 스레드가 하나씩 생성되어 할당된다.
  * 스레드 폴에서는 커넥션과 포그라운드 스레드가 1:1 관계가 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담한다.

### 포그라운드 스레드
* MySQL 서버에 접속된 클라이언트 수만큼 존재한다.
* 주로 각 클라이언트가 요청하는 쿼리 문장을 처리한다.
* 클라이언트가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다.
  * 이때 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 된다.
* 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
* MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
* InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

### 백그라운드 스레드
* InnoDB 는 다음과 같이 여러 작업이 백그라운드 스레드로 처리된다.
  * 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  * 로그를 디스크로 기록하는 스레드
  * InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  * 데이터를 버퍼로 읽어 오는 스레드
  * 잠금이나 데드락을 모니터링하는 스레드
* 일반적인 DBMS는 데이터의 쓰기작업은 버퍼링을 통해 지연되어 처리될 수 있지만 읽기 작업은 지연되지 않으며, InnoDB도 마찬가지다.
  * 따라서 InnoDB에서는 CUD 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
  * MyISAM은 그렇지 않고, 포그라운드 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다. (일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.)
  * 결론은 InnoDB를 쓰자.

## 메모리 할당 및 사용 구조
![img.png](assets/memory_allocation_structure.png)

### 글로벌 메모리 영역
* 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
* 일반적으로 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당된다.
  * 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트 스레드 수와 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.

### 로컬 메모리 영역
* MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
* 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현한다.
* 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.
* 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차 하지 않을 수도 있다. (소트 버퍼나 조인 버퍼 등..)
* 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있다. (커넥션 버퍼나 결과 버퍼)

## MySQL 엔진과 스토리지 엔진 처리 영역
![MySQL 엔진과 스토리지 엔진 처리 영역](assets/mysql_engine_storage_engine.png)
* MySQL에서 쿼리가 실행될 때, 거의 대부분의 작업이 MySQL 엔진에서 처리되고, 데이터 읽기/쓰기 작업만 스토리지 엔진에서 처리된다.
* MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.
> 핸들러는 MySQL 엔진이 스토리지 엔진을 조정하기 위해 사용된다.
* GROUP BY나 ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 '쿼리 실행기'에서 처리된다.

## 쿼리 실행 구조
![쿼리 실행 구조.png](assets/query_execution_structure.png)

### 쿼리 파서
* 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만든다.
* 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달한다.

### 전처리기
* 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 
* 각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행한다.
* 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

### 옵티마이저
* 사용자의 요청으로 들어온 쿼리 문장을 어떻게 하면 저렴한 비용으로 가장 빠르게 처리할 수 있을지를 결정하는 역할을 담당한다.

### 실행 엔진
* 옵티마이저에 의해 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행하고, 그 결과를 클라이언트에게 응답한다.

### 핸들러 (스토리지 엔진)
* MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
